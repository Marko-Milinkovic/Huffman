# Huffman Algorithm based File Compressor

[![Code Coverage](https://img.shields.io/badge/coverage-95%25-brightgreen)](https://github.com/Marko-Milinkovic/Huffman-coding)
![C++ Standard](https://img.shields.io/badge/C%2B%2B-17-blue)

A high-performance, real-world file compressor built in C++ using the Huffman coding algorithm ‚Äî the same core algorithm behind ZIP and other industry-standard formats.

This tool takes an input file, analyzes symbol frequencies, constructs an optimal Huffman binary prefix tree, encodes the content at the bit level, and outputs a compressed binary file with significantly reduced size (typically 40‚Äì60% smaller, depending on entropy) ready for reconstruction. It guarantees lossless compression ‚Äî the decompressed output is identical to the original, with no risk of data corruption.

Designed for speed, efficiency, and correctness, it implements the full compression-decompression pipeline with custom serialization and bitstream handling.

Following image explains basic logic of Huffman algorithm.



<p align="center">
  <img src="assets/huffman_tree.png" alt="Huffman Tree" width="500"/><br>
  <em>
    Visual representation of a Huffman Tree. Leaf nodes show symbols (like 'a', 'b', etc.) along with their frequencies ‚Äî which reflect how often each symbol occurs in the input. Internal nodes combine these frequencies as the tree is built from bottom up.
Binary codes for each symbol are generated by traversing the tree: taking a left branch appends a '0', while a right branch appends a '1'.
For example, if the path from root to 'a' is ‚Äúleft ‚Üí right ‚Üí left‚Äù, then its binary code is ‚Äú010‚Äù. This replaces the standard 8-bit ASCII encoding with a 3-bit code, reducing size.
Symbols with higher frequency are placed closer to the root, receiving shorter codes ‚Äî which is the essence of Huffman‚Äôs compression efficiency.
  </em>
</p>



---

## Key Features

- **Lossless compression** using canonical Huffman codes
- **Supports both compression and decompression** of files
- **Algorithmic efficiency**: optimized hashing for symbol frequency analysis and tree construction using min-heap priority-queue
- **Recursive serialization/deserialization** of the Huffman tree
- **Custom binary format** for decompression compatibility
- **Bit-level symbol encoding** for optimal file size reduction
- **Compression metrics**: shows input size, output size, compression ratio, space savings and bits per symbol
- **Code table analysis**: binary code length of each symbol, frequency distribution
- **Robust testing suite** covering edge cases including empty files and single-symbol inputs
- **Dynamic memory management** with rigorous leak-free guarantees 
  
---

## Technical Highlights

### Core Algorithm  
- **Frequency Analysis**: Utilizes a high-performance hash map to count symbol occurrences in O(n) time, where *n* is the input file size.  
- **Priority Queue Construction**: Implements a min-heap to build the Huffman tree efficiently in O(k log k) time, where *k* is the number of unique symbols.  
- **Huffman Tree Formation**: Combines nodes by repeatedly extracting the two lowest-frequency elements, ensuring an optimal prefix code minimizing average code length. Leaf nodes hold characters and frequencies, internal nodes store combined frequencies. 
- **Recursive Tree Serialization/Deserialization**: Employs preorder traversal to serialize the tree structure into a compact binary format, enabling exact reconstruction during decompression.  

### Bit-Level Operations  
- **Bitstream I/O**: Custom routines pack and unpack symbols bit-by-bit to maximize compression, leveraging bitwise shifts and masks for speed and minimal memory overhead.  
- **Canonical Codes**: Generates canonical Huffman codes to streamline encoding and decoding processes, reducing metadata size and simplifying decoder logic.  

### C++ Concepts & Implementation Details  
- **Standard Library Data Structures**: Utilizes `std::vector`, `std::priority_queue`, and `std::unordered_map` for efficient frequency counting, symbol storage, and priority queue management.  
- **Pointer Arithmetic and Dynamic Memory Management**: Employs raw pointers with careful manual management in performance-critical parts to optimize memory usage.  
- **Bitwise Operators and Masks**: Implements compact encoding and decoding through efficient use of bitwise shifts and masks for bit-level data manipulation.  
- **Error Handling and Validation**: Integrates comprehensive error checking for all I/O and memory operations, guaranteeing safe decompression with no data loss.  

## Benchmarks

| File         | Original Size | Compressed | Ratio | Time (ms) |
|--------------|----------------|------------|-------|-----------|
| `1KB.txt`    | 1.0 KB         | 0.6 KB     | 60%   | 1.2       |
| `10KB.txt`   | 10.0 KB        | 5.8 KB     | 58%   | 4.8       |
| `100KB.txt`  | 100.0 KB       | 61.2 KB    | 61%   | 32.1      |

---

## Conclusion

This project efficiently compresses input files into a compact binary format using Huffman coding and reliably decompresses them back without data loss, delivering significant storage savings. 
It leverages a diverse set of data structures‚Äîincluding hash maps, priority queues, and binary trees for maintaining low time complexity.
By combining high-level C++ STL abstractions with low-level bitwise operations and manual memory management, it exemplifies a powerful synergy of algorithmic precision and systems-level programming.

---

## License

This project is licensed under the [MIT License](LICENSE).

---

## Contact

Marko Milinkoviƒá  
üìß Email: [markom11080@gmail.com]  
üîó GitHub: [github.com/Marko-Milinkovic](https://github.com/Marko-Milinkovic)

---
